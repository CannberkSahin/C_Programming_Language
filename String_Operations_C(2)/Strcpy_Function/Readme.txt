Canberk ŞAHİN
E-Mail: canberk_cas@hotmail.com

C codes are written in the CodeBlocks development environment.
The object code file was created by compiling the C code. 
It has also been tested whether it works or not. It works without any problems.
Standard C libraries are used.These are stdio.h and stdlib.h
If you want to run the program, you can find the .exe extension in the bin folder.

There are many standard functions for string operations in C language. In this program, 
a standard C function strcpy function is implemented. The function has been implemented in two ways.
The first method is the classical pointer method. The second way is the pointer idiom.
strcpy is a function that copies the elements from one array to another.

strcpy: Defined in header <string.h>
====================================
char *strcpy( char *dest, const char *src ); 
char *strcpy( char *restrict dest, const char *restrict src ); //(until C99)

1) Copies the null-terminated byte string pointed to by src, including the null terminator, 
to the character array whose first element is pointed to by dest.The behavior is undefined 
if the dest array is not large enough. The behavior is undefined if the strings overlap. 
The behavior is undefined if either dest is not a pointer to a character array or src is not 
a pointer to a null-terminated byte string.

2) Same as (1), except that it may clobber the rest of the destination array with unspecified 
values and that the following errors are detected at runtime and call the currently installed 
constraint handler function: 
*src or dest is a null pointer
*destsz is zero or greater than RSIZE_MAX
*destsz is less or equal strnlen_s(src, destsz); in other words, truncation would occur
*overlap would occur between the source and the destination strings

The behavior is undefined if the size of the character array pointed to by 
dest <= strnlen_s(src, destsz) < destsz; in other words, an erroneous value of destsz does not 
expose the impending buffer overflow.
As with all bounds-checked functions, strcpy_s is only guaranteed to be available if __STDC_LIB_EXT1__ 
is defined by the implementation and if the user defines __STDC_WANT_LIB_EXT1__ to the integer 
constant 1 before including string.h.

Parameters
==========
dest - pointer to the character array to write to
src  - pointer to the null-terminated byte string to copy from
destsz	- maximum number of characters to write, typically the size of the destination buffer.

Return value
============
1) returns a copy of dest
2) returns zero on success, returns non-zero on error. Also, on error, writes zero to dest[0] 
(unless dest is a null pointer or destsz is zero or greater than RSIZE_MAX).
(Cited: cppreference.com)

Two strcpy functions are written in the program. The first one is strcpy1 and the second is strcpy2.
The function has two parameters. The first one asks for the address of the directory to be copied.
The second is the address of the copied directory, the source directory. 
These parameters should conventionally be written in the C language as such. In other words, 
the source should be written after the destination.The return value of the function is pdest.
In the first function, a while loop is written to traverse the array, and a null character is tested in it.
Then the elements in the source have been assigned to the destination one by one.
Null character has been assigned to the end of the copied directory. Finally, it is returned with the 
address of the copied directory.

The second written function is one of the most important idioms of the C language.
The value generated by the assignment operator is the value assigned to the object.
The assignment for copying the elements of the array is written in the while statement.
The body of the loop is also made a null statement (; statement is a null statement).
As long as the assigned value is not 0, the loop continues. The value of a null character is 0. Therefore, 
when it comes to the null character, the loop ends.
So the loop copied the null character in the text. Therefore, there is no need to add a null character 
to the end of the array at the exit of the loop.

Good work and Best Regards.